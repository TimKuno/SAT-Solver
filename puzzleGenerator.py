import random
from pysat.solvers import Glucose3


class PuzzleGenerator:
    def __init__(self):
        """
        Constructor.
        """
        self.row = []
        self.column = []
        self.field = []
        self.write_field = []
        self.puzzleSize = 0
        self.N = 0
        self.alphabet = []
        self.file_name = ""

    def generatePuzzle(self, file_name, size):
        """
        Generates the puzzle and sets it's name and size.
        
        Args:
            file_name (string): The name of the puzzle
            size (integer): The size of the puzzle
        """
        self.puzzleSize = size
        self.N = size
        self.file_name = file_name
        self.generateField()
        self.writeField()
        self.generateContraints()
        self.writeConstraints()

    def generateField(self):
        """
        Generate the field with the aquariums
        """
        counter = 0
        for i in range(self.puzzleSize):
            column = []
            for k in range(self.puzzleSize):
                if i == 0: # first line
                    if random.randint(0, 100) <= 60: # decide if a new aquariumn is started or the previous one is continued
                        column.append('a' + str(counter))
                    else:
                        counter += 1
                        column.append('a' + str(counter))
                else:
                    if random.randint(0, 100) <= 60: # decide if a new aquarium is started or the previous one is continued
                        if random.randint(0, 100) <= 50: # decide if a new aquarium is created or the one above is continued
                            column.append(self.field[i - 1][k])
                        else:
                            counter += 1
                            column.append('a' + str(counter))
                    else:
                        counter += 1
                        column.append('a' + str(counter))

            self.field.append(column)
            self.write_field.append(column)

        # add characters to alphabet
        for line in self.field:
            for character in line:
                if character not in self.alphabet:
                    self.alphabet.append(character)

    def map(self, i, j):
        """
        Maps the two indices from the puzzle to one indice that the solver needs.
        """
        return i * self.N * self.N + j * self.N + 1

    def unmap(self, n):
        """
        Maps the one indice that the solver needs back to the two indices from the puzzle.
        """
        n = n - 1
        n = int(n / self.N)
        i = int(n / self.N)
        j = n % self.N

        return i, j

    def generateContraints(self):
        solver = Glucose3()
        # set aquarium constraints
        aquariums = []
        for letter in self.alphabet:
            aquarium = []
            for i in range(self.N):
                for j in range(self.N):
                    if letter == self.field[i][j]:
                        aquarium.append([i, j])
            aquariums.append(aquarium)

            for i in range(len(aquarium) - 1, -1, -1):
                row, column = aquarium[i]

                for k in range(len(aquarium) - 1, -1, -1):
                    row2, column2 = aquarium[k]
                    if row2 >= row and aquarium[k] != aquarium[i]:
                        clause = [-self.map(row, column), self.map(row2, column2)]
                        solver.add_clause(clause)
                        
        # make sure that the puzzle is solvable
        assumptions_list = []
        for i in range(((self.N * self.N) // 100) * 60):  # percentage of water fields (e.g. 60% from 100 x 100 are 6000 water fields)
            assumptions_list.append(random.randint(self.map(0, 0), self.map(self.N - 1, self.N - 1)))
        solver.solve(assumptions=assumptions_list)

        for i in solver.get_model():
            if i > 0:
                (i, j) = self.unmap(i)
                # this is neccessary due to the variables that are internally generated by the solver, which would exceed the bounds of the puzzle otherwise
                if i < self.N and j < self.N:
                    self.field[i][j] = "W"

        # count the number of waterfields
        for i in range(self.N):
            column_counter = 0
            row_counter = 0
            for k in range(self.N):
                if self.field[i][k] == "W":
                    column_counter += 1
                if self.field[k][i] == "W":
                    row_counter += 1
            self.column.append(column_counter)
            self.row.append(row_counter)

    def writeField(self):
        """
        Write the puzzle in the txt file
        """
        text_file = open(self.file_name + ".txt", "w")
        for x in self.row:
            text_file.write(str(x) + ' ')
        text_file.write('\n')

        for x in self.column:
            text_file.write(str(x) + ' ')
        text_file.write('\n')

        for column in range(self.N):
            for row in range(self.N):
                if row < self.N - 1:
                    text_file.write(self.field[column][row] + ' ')
                else:
                    text_file.write(self.field[column][row])
            if column < self.N - 1:
                text_file.write('\n')

        text_file.close()

    def writeConstraints(self):
        """
        Write the constraints in the first two rows of the txt file
        """
        with open(self.file_name + ".txt") as text_file:
            data = text_file.readlines()

        row = ""
        for x in range(self.N):
            if x < self.N - 1:
                row += str(self.row[x]) + ' '
            else:
                row += str(self.row[x]) + '\n'

        data[0] = row

        column = ""
        for x in range(self.N):
            if x < self.N - 1:
                column += str(self.column[x]) + ' '
            else:
                column += str(self.column[x]) + '\n'

        data[1] = column

        with open(self.file_name + ".txt", "w") as file:
            file.writelines(data)


if __name__ == "__main__":
    puzzle = PuzzleGenerator()
    # setting name and size (e.g. 20 means 20 X 20) of the puzzle that will be generated
    puzzle.generatePuzzle("GeneratedPuzzle_20x20", 20)
