from pysat.card import CardEnc, EncType
from pysat.solvers import *
import time


def trimLine(line):
    return [character for character in line.split()]


class Aquarium:
    def __init__(self, filename):
        """
        Constructor.
        """
        self.row = []
        self.column = []
        self.data = []
        self.alphabet = []
        tmpData = []
        with open(filename) as reader:
            line = reader.readline()
            while line != '':
                tmpData.append(trimLine(line))  # append line
                line = reader.readline()
        for index, line in enumerate(tmpData):
            if index == 0:
                self.column = [int(l) for l in line]
            elif index == 1:
                self.row = [int(l) for l in line]
            else:
                self.data.append(line)
                # add characters to alphabet
                for character in line:
                    if character not in self.alphabet:
                        self.alphabet.append(character)
        self.N = len(self.data)

    def map(self, i, j):
        """
        Maps the two indices from the puzzle to one indice that the solver needs.
        """
        return i * self.N * self.N + j * self.N + 1

    def unmap(self, n):
        """
        Maps the one indice that the solver needs back to the two indices from the puzzle.
        """
        n = n - 1
        n = int(n / self.N)
        i = int(n / self.N)
        j = n % self.N

        return i, j

    def model(self, solver):
        """_summary_

        Args:
            solver (any): The solver that is used.
        """
        # Hints: 
        # The from cnf.clauses generated variables need to lay outside of the layout range!
        # The from cardinalityEncoding generated variables must not be duplicated!

        # row constraints (x times water in the row)
        for i in range(self.N):  # row
            rowIndices = []
            for j in range(self.N):  # column
                rowIndices.append(self.map(i, j))
            cnf = CardEnc.equals(lits=rowIndices, top_id=self.map(self.N, self.N) + self.N * self.N * i,
                                 bound=self.row[i], encoding=EncType.seqcounter)
            solver.append_formula(cnf)

        # column constraints (x times water in the column)
        for i in range(self.N):  # row
            columnIndices = []
            for j in range(self.N):  # column
                columnIndices.append(self.map(j, i))
            cnf = CardEnc.equals(lits=columnIndices, top_id=self.map(self.N, self.N) + self.N * self.N * self.N * (i + 1),
                                 bound=self.column[i], encoding=EncType.seqcounter)
            solver.append_formula(cnf)

        # aquarium constraints (every row of an aquarium needs to be filled completely and the unerlying of the aquarium)
        aquariums = []
        for letter in self.alphabet:
            aquarium = []
            for i in range(self.N):
                for j in range(self.N):
                    if letter == self.data[i][j]:
                        aquarium.append([i, j])
            aquariums.append(aquarium)

            for i in range(len(aquarium) - 1, -1, -1):
                row, column = aquarium[i]

                for k in range(len(aquarium) - 1, -1, -1):
                    row2, column2 = aquarium[k]
                    if row2 >= row and aquarium[k] != aquarium[i]:
                        clause = [-self.map(row, column), self.map(row2, column2)]
                        solver.add_clause(clause)

    def fillContent(self, model):
        """
        Fills the puzzle with W for water.

        Args:
            model (any): The model of the solver that was used.
        """
        for i in model:
            if i > 0:
                (i, j) = self.unmap(i)
                # this is neccessary due to the variables that are internally generated by the solver, which would exceed the bounds of the puzzle otherwise
                if i < self.N and j < self.N:
                    self.data[i][j] = "W"

    def printSolution(self):
        """
        Prints the solved aquarium puzzle in the terminal.
        """
        for line in self.data:
            print(line)

    def solve(self):
        """
        Solves the aquarium puzzle and takes the solution time.
        """
        solver = Cadical()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"Cadical: {end - start}")

        solver = Gluecard3()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"Gluecard3: {end - start}")

        solver = Gluecard4()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"Gluecard4: {end - start}")

        solver = Glucose3()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"Glucose3: {end - start}")

        solver = Glucose4()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"Glucose4: {end - start}")

        solver = Lingeling()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"Lingeling: {end - start}")

        solver = MapleChrono()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"MapleChrono: {end - start}")

        solver = MapleCM()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"MapleCM: {end - start}")

        solver = Maplesat()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"Maplesat: {end - start}")

        solver = Mergesat3()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"Mergesat3: {end - start}")

        solver = Minicard()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"Minicard: {end - start}")

        solver = Minisat22()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"Minisat22: {end - start}")

        solver = MinisatGH()
        self.model(solver)
        start = time.time()
        solver.solve()
        end = time.time()
        print(F"MinisatGH: {end - start}")

        if solver.solve():
            print("Satisfiable!")
            self.fillContent(solver.get_model())
            self.printSolution()

        else:
            print("Unsatisfiable!")


if __name__ == "__main__":
    print("---------------------------------------------------------------------")
    print("20x20")
    aquarium = Aquarium("GeneratedPuzzle_20x20.txt")
    aquarium.solve()
